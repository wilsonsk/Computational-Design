---
up:
  - "[[Data Control]]"
related:
  - "[[Data]]"
  - "[[Data Operations]]"
date created: 2024-04-16
---
# Loops
Method for implementing [[Cybernetics|feeback mechanisms]] into a system or component.
## Recursive Algorithms
Implement loops in such a way that a "downstream" output is used as an "upstream" input.
The loop (i.e. procedure) can repeat itself $n$ times, generating an output at the end of each iteration or step through the procedure (i.e. loop). 

![[Pasted image 20240416125316.png|400]]

The first iteration requires an **edge condition**.
	That is, one or more **initial** inputs that is not defined recursively.
The subsequent iterations are defined by data loops.
	In that the output of an iteration replaces the initial edge condition input. 

Recursive algorithms are powerful because they can be used to generate a multitude of geometries by a short and simple process. 
### *An example of a recursive procedure*: Divide a line
1. Draw a line to define an edge condition, the line 0.
2. Divide the line into three segments: segment 0, segment 1, segment 2.
3. Translate segment 1 by three units along the y-axis.
4. Output this translated segment as line 1.
5. Repeat step 2. and step 3. using line 1. 
![[Pasted image 20240416125947.png|500]]
The Grasshopper conversion:
![[Pasted image 20240416130012.png|500]]
- The problem is that this definition can only iterate one time. 
	- Output from the **Move** component would have to be wrapped back to replace the initial curve input.
		- And this non-linear flow conflicts with Grasshopper's linear-flow logic. 
			- I.e. "Left to Right logic".
			- ![[Pasted image 20240416130737.png]]

The solution is are plugin components, **HoopSnake** and **Loop**.
	Which enable feedback loops to be defined in Grasshopper.
## HoopSnake Component
Enables users to defy the "left to right" logic and perform loop operations.
- Inputs:
	- (S): Starting Data- that is the, the edge condition.
		- This will be (F) output just once at the beginning, before any subsequent loop iterations are performed.
	- (D*): Represents the collection of generic data- that is, the input for the looped output.
	- (B*): Iteration count.
		- Accepts either a Boolean or a number. 
			- If the Boolean is False, or the current iterations count is equal to or greater than the input number, then the loop will stop.
	- (T*): Will trigger a HS iteration if the content of the input has changed.
- Outputs:
	- (F): Feedback output - that is, an unmodified copy of the (S) input.
		- If (S) input is not provide, then it yields an unmodified copy of the (D*) input.
	- (C): Cumulative feedback output.
		- A data Tree containing each output of a loop iteration as a branch.
	- (L): Loops counter, a count of the number of loops.
	- (I): Iterations counter.

*Using the previous example of a Divide Line procedure*:
![[Pasted image 20240416130925.png|500]]
1. The edge condition is the referenced **Curve** component passed into the (S) input of the **HoopSnake** component (aka **HS** component). 
	- The (F) output is the **HS** component is also the unmodified edge condition (i.e. S input).
2. The (F) output replaces the **Curve** component as an input to the **Divide** component and **Shatter** component. 
3. The (G) output of the **Move** component is brought back and connected to the (D*) input of the **HS** component.
	- Defining the loop structure.
4. The (C) output of the **HS** component returns the cumulative output after all iterations of the loops. 
	- Each existing as a branch of a [[Data Trees|Data Tree]].


## Fractals
Are patterns that are [[Digital Informing Creativity#Self-Similarity|self-similar]] across scales.
	Self-similar: A [[Abstract Mathematical Objects|mathematical object]] that is similar to itself on all scales. 
		A self-similar structure can be decomposed into parts which are exact replicas of the whole.

They are generated by repeating a simple procedure using feedback loops. 
	Repeat at increasingly smaller scales, producing complex shapes. 

*Example:* Koch Snowflake Curve
![[Pasted image 20240416134014.png|400]]
Is found as the [[Limits|limit]] of an infinite sequence of approximations.
	Step 0: The first approximation is a straight line segment.
	Step 1: The middle third of this segment is then replaced by segments (whose length is equal to the middle third) which are joined like two sides of an equilateral triangle.
	Step 3: Each line segment has its middle third replaced by two segments which form an equilateral triangle. 
"We can regard the limit of this infinite process as being a curve that actually exists if not in physical space, then at least as a mathematical object." - R. Rucker
![[Pasted image 20240416134420.png]]
### Divide Curve component: 
Divides a curve into equal length segments. 
- Inputs:
	- (C): Curve to divide.
	- (N): Number of segments.
	- (K): Split segments at kinks.
- Outputs:
	- (P): List of division points.
	- (T): Tangent vectors at division points.
	- (t): Parameter values at division points. 
### Shatter component:
Shatters a curve into segments.
	- Inputs:
		- (C): Curve to trim.
		- (t): Parameters to split at. 
	- Outputs:
		- (S): List of shattered segments.

1. The **Divide Curve** component even divides 3 segments of the referenced curve.
2. The parameter values of each position of division is passed to the (t) parameters to split at, input of the **Shatter** component. 
3. The output shattered line segments are passed in to a **[[Data Operations#List Item component|List Item]]** component with 1 as the indices (i) input.