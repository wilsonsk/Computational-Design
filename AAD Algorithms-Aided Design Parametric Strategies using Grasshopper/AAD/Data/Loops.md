---
up:
  - "[[Data Control]]"
related:
  - "[[Data]]"
  - "[[Data Operations]]"
date created: 2024-04-16
---
# Loops
Method for implementing [[Cybernetics|feeback mechanisms]] into a system or component.
## Recursive Algorithms
Implement loops in such a way that a "downstream" output is used as an "upstream" input.
The loop (i.e. procedure) can repeat itself $n$ times, generating an output at the end of each iteration or step through the procedure (i.e. loop). 

![[Pasted image 20240416125316.png|400]]

The first iteration requires an **edge condition**.
	That is, one or more **initial** inputs that is not defined recursively.
The subsequent iterations are defined by data loops.
	In that the output of an iteration replaces the initial edge condition input. 

Recursive algorithms are powerful because they can be used to generate a multitude of geometries by a short and simple process. 
### *An example of a recursive procedure*: Divide a line
1. Draw a line to define an edge condition, the line 0.
2. Divide the line into three segments: segment 0, segment 1, segment 2.
3. Translate segment 1 by three units along the y-axis.
4. Output this translated segment as line 1.
5. Repeat step 2. and step 3. using line 1. 
![[Pasted image 20240416125947.png|500]]
The Grasshopper conversion:
![[Pasted image 20240416130012.png|500]]
- The problem is that this definition can only iterate one time. 
	- Output from the **Move** component would have to be wrapped back to replace the initial curve input.
		- And this non-linear flow conflicts with Grasshopper's linear-flow logic. 
			- I.e. "Left to Right logic".
			- ![[Pasted image 20240416130737.png]]

The solution is are plugin components, **HoopSnake** and **Loop**.
	Which enable feedback loops to be defined in Grasshopper.
## HoopSnake Component
Enables users to defy the "left to right" logic and perform loop operations.
- **Inputs**:
	- (S): Starting Data- that is the, the edge condition.
		- This will be (F) output just once at the beginning, before any subsequent loop iterations are performed.
	- (D*): Represents the collection of generic data- that is, the input that takes the looped output.
	- (B*): Iteration count.
		- Accepts either a Boolean or a number. 
			- If the Boolean is False, or the current iterations count is equal to or greater than the input number, then the loop will stop.
	- (T*): Will trigger a HS iteration if the content of the input has changed.
- **Outputs**:
	- (F): Feedback output - that is, an unmodified copy of the (S) input.
		- If (S) input is not provide, then it yields an unmodified copy of the (D*) input.
	- (C): Cumulative feedback output.
		- A data Tree containing each output of a loop iteration as a branch.
	- (L): Loops counter, a count of the number of loops.
	- (I): Iterations counter.

*Using the previous example of a Divide Line procedure*:
![[Pasted image 20240416130925.png|500]]
1. The edge condition is the referenced **Curve** component passed into the (S) input of the **HoopSnake** component (aka **HS** component). 
	- The (F) output is the **HS** component is also the unmodified edge condition (i.e. S input).
2. The (F) output replaces the **Curve** component as an input to the **Divide** component and **Shatter** component. 
3. The (G) output of the **Move** component is brought back and connected to the (D*) input of the **HS** component.
	- Defining the loop structure.
4. The (C) output of the **HS** component returns the cumulative output after all iterations of the loops. 
	- Each existing as a branch of a [[Data Trees|Data Tree]].
## Fractals
Are patterns that are [[Digital Informing Creativity#Self-Similarity|self-similar]] across scales.
	Self-similar: A [[Abstract Mathematical Objects|mathematical object]] that is similar to itself on all scales. 
		A self-similar structure can be decomposed into parts which are exact replicas of the whole.

They are generated by repeating a simple procedure using feedback loops. 
	Repeat at increasingly smaller scales, producing complex shapes. 
### *Example:* Koch Snowflake Curve
![[Pasted image 20240416134014.png|400]]
Is found as the [[Limits|limit]] of an infinite sequence of approximations.
	Step 0: The first approximation is a straight line segment.
	Step 1: The middle third of this segment is then replaced by segments (whose length is equal to the middle third) which are joined like two sides of an equilateral triangle.
	Step 3: Each line segment has its middle third replaced by two segments which form an equilateral triangle. 
"We can regard the limit of this infinite process as being a curve that actually exists if not in physical space, then at least as a mathematical object." - R. Rucker
#### The Procedure
![[Pasted image 20240416134420.png]]
##### Part 1: Extracting the lines and calculate corresponding offset. 
1. A curve component (a list of lines where each line is a branch) is input into a **Divide Curve** component and **Shatter** component.
1. The **Divide Curve** component even divides 3 segments of the referenced curve.
2. The parameter values of each position of division is passed to the (t) parameters to split at, input of the **Shatter** component. 
3. The output shattered line segments are passed in to a **[[Data Operations#List Item component|List Item]]** component with 1 as the indices (i) input.
4. The length of the shattered segment at index 1, is divided by 2 and then scaled by the square root of three.
5. The evaluated output value is converted to a negative value, then used as the distance of an  offset curve of the shattered segment (at index 1). 
##### Part 2: Merging the new lines (i.e. creating two new lines with end/start points connecting to offset point).
1. The offset value is the input for two **Line** components. 
	1. The (B) input for line 1.
		- Who has a corresponding (A) input that is start point of the shattered line segment.
	2. The (A) input for line 2.
		- Who has a corresponding (B) input that is end point of the shattered line segment.
2. A **Merge** component takes in three inputs: generating a list/branch
	1. (D1) Input: Receives the output list from a **Cull Item** component which culls the index 1 item of the shattered lines segments. 
		- I.e. The list of shattered line segments **not** containing the evaluated shattered line segment used as the negative offset value.
	2. (D2) Input: Receives Line 1 (start point of selected, shattered line segment -> offset).
		- Start point is start point of the shattered line segment.
		- End point is the offset value. 
	3. (D3) Input: Receives Line 2 (offset -> end point of selected, shattered line segment).
		- Start point is the offset value.
		- End point is the end point of the shattered line segment. 
2. The resulting List is **[[Data Trees#Graft Tree component/operation|Grafted]]**, meaning each list item becomes its own branch.
	- Meaning each line of this list is its own branch.
		- Therefore, in the subsequent iterations, each branch of this list is divided and shattered itself.
			- Each with its own offset and new generated new lines.
##### Part 3: The iteration (loop).
1. A **HoopSnake** component:
	- Containing the inputs:
		1. (S) Edge condition input: Is the initial, non-shattered curve.
		2. (D*) Looping input: The resulting merged list (containing the selected, shattered line segment, line 1 and line 2).
		3. (B*) Iteration count input is set to 4.
	- Containing the output:
		1. (F) Unmodified starting data and then looped data: is used as the input for the **Shatter** component (replacing the static referenced curve).
			- Closing the loop.

Before any loop/iteration:
![[Pasted image 20240417191703.png]]
After 1 loop/iteration:
A list of lines (each line is a branch) is input into **Divide** and **Shattered** components.
Each branch of lines is divided and shattered into 3 segments.
The 1st element of shattered segments list is extract.
	The offset is calculate relative to this 1st element.
The 2 news lines are connected between:
	The start point of the 1st element line and the offset point.
	The offset point and the end point of the 1st element line.
The non 1st element line segments, and the 2 new lines are merged into a **Grafted** list.
	This list is passed back in as input to the initial loop.
![[Pasted image 20240417191548.png]]
Loop/iteration 2:
![[Pasted image 20240417192053.png]]
Loop/iteration 3:
![[Pasted image 20240417193320.png]]
Loop/iteration 4:
![[Pasted image 20240417193334.png]]
##### Divide Curve component: 
Divides a curve into equal length segments. 
- Inputs:
	- (C): Curve to divide.
	- (N): Number of segments.
	- (K): Split segments at kinks.
- Outputs:
	- (P): List of division points.
	- (T): Tangent vectors at division points.
	- (t): Parameter values at division points. 
##### Shatter component:
Shatters a curve into segments.
	- Inputs:
		- (C): Curve to trim.
		- (t): Parameters to split at. 
	- Outputs:
		- (S): List of shattered segments.
##### Offset Curve component;
Offsets a curve with a specified distance.
- Inputs:
	- (C): Curve to Offset.
	- (D): Offset distance.
	- (P): Plane for offset operation.
	- (C): Corner type flag. 
		- 0: None.
		- 1: Sharp.
		- 2: Round.
		- 3: Smooth.
		- 4: Chamfer.
	- Outputs:
		- (C): Resulting offset.
##### End Points Component
Extracts the end points of a curve.
- Inputs:
	- (C): Curve to evaluate.
- Outputs:
	- (S): Start point of the curve.
	- (E): End point of the curve.
## Practical Fractals
### *Example:* Toyo Ito's and Cecil Balmond's 2002 Serpentine Pavilion
The apparently random pattern was derived from a recursive algorithm.

"I propose an algorithm: half to a third of adjacent sides of the square. The 1/2 to 1/3 rule traces four lines in the original square that do not meet [...]. The half to a third rule forces one to go out of the original square to create a new square so that the rule, the algorithm, may continue [...] and a primary structure is obtained. Then if these lines are all extended, a pattern of many crossings results. Some are primary for load bearing, some will serve as bracings to secondary and the rest will be a binding motif of the random across the surface of the box typology". (Cecil Balmond)

![[Pasted image 20240417193837.png]]

## Tri-dimensional Fractals
Follow same logic as bi-dimensional fractals. 
In the following example a 3D fractal is created from three points and performing three iterations.
![[Pasted image 20240417234937.png]]

### Procedure
1. The **Delaunay Triangulation** component defines a triangular mesh is defined via referenced three points.
2. Each face's centroid is translated (in the direction normal to the face and scaled by 2).
3. **wbEdges** component extracts the edges of the mesh.
4. The start and end points of each edge are extracted.
5. The start and end points and translated centroids, are cross referenced into three new lists.
6. The three lists are merged.
7. The points are culled.
8. The **Delaunay Triangulation** component is used again to now define three new faces.
9. The new, extracted faces are now used as the initial (D*) input.
	- Iterate loop n times. 
![[Pasted image 20240417235655.png|500]]
#### Weaverbird Mesh Edges (aka wbEdges) Component
- Inputs: 
	- (G): The open or closed mesh, or closed polyline group, from which to extract the wireframe.
- Outputs:
	- (L): The list of wires - or edge lines - constituting the mesh.

## Loops in Grasshopper: Loop Component
An alternative to the **HoopSnake** component.
Developed by Antonio Turiello. 

The Loop method uses three components:
### Rnd Component
Generates a list of pseudo random numbers, updated by a **Time** component or by the **Recompute** command. 

### Store Component
Stores data between updates.

### Loop Component
Is used to iterate a procedure by replacing an input parameter of the procedure's initial component with an output parameter of the procedure's final component.